<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>taihen.org / 418 ... engineering in progress</title><link>https://taihen.org/</link><description>Recent content on taihen.org / 418 ... engineering in progress</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 17 Feb 2024 12:00:00 +0000</lastBuildDate><atom:link href="https://taihen.org/index.xml" rel="self" type="application/rss+xml"/><item><title>About</title><link>https://taihen.org/about/</link><pubDate>Sat, 17 Feb 2024 12:00:00 +0000</pubDate><guid>https://taihen.org/about/</guid><description>&lt;h2 id="who-am-i">Who Am I?&lt;/h2>
&lt;p>I&amp;rsquo;m a staff level infrastructure engineer with a love for creating innovative solutions and exploring new technologies.&lt;/p>
&lt;p>I’ve seen it all (well, almost): from servers under you desk, the wild west days of configuration management, through the cloud’s grand entrance, survived the container orchestrator wars (who remembers &lt;a href="https://www.slideshare.net/slideshow/aravindnarayanan-facebook140613153626phpapp02-37588997/37588997">Tupperware?&lt;/a>), and now I’m all aboard the Kubernetes train. But deep down though, I’m just a Linux guy.&lt;/p>
&lt;h2 id="what-do-i-do">What Do I Do?&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>System Engineering:&lt;/strong> Building system engineering tools for performance, automation and experience.&lt;/li>
&lt;li>&lt;strong>Infrastructure Engineering:&lt;/strong> Developing scalable infrastructure solutions.&lt;/li>
&lt;li>&lt;strong>Tech Outreach:&lt;/strong> Sharing insights, tutorials, and experiences.&lt;/li>
&lt;/ul>
&lt;p>I’ve spent most of my career in the Telco world, first as a entrapanur and engineer, later trainer and evangelist. I’ve had the privilege of speaking at events about global routing security, IPv6, and DNSSEC — topics that really make my heart race (in a good way)!&lt;/p></description></item><item><title>Contact</title><link>https://taihen.org/contact/</link><pubDate>Sat, 17 Feb 2024 12:00:00 +0000</pubDate><guid>https://taihen.org/contact/</guid><description>&lt;p>Whether you have a question, feedback, or just want to say hello, feel free to reach out.&lt;/p>
&lt;h3 id="get-in-touch">Get In Touch&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.linkedin.com/in/taihen">LinkedIn Profile&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Managing dotfiles with GNU Stow</title><link>https://taihen.org/posts/stow/</link><pubDate>Wed, 11 Sep 2013 22:36:36 +0100</pubDate><guid>https://taihen.org/posts/stow/</guid><description>&lt;blockquote>
&lt;p>In Unix-like operating systems, dotfile is synonymous with hidden file. Usually used by programs to store configuration variables.&lt;/p>&lt;/blockquote>
&lt;p>I have multiple machines, which I regularly work on. I keep sync of a set of personalized dotfiles between them – customized settings for programs that I’m using, like many of you. Till now, I was using my private git repository for things like my private scripts, &lt;a href="http://www.mutt.org/" title="Mutt E-Mail Client">Mutt&lt;/a>, &lt;a href="http://www.irssi.org/" title="Irssi IRC Client">Irssi&lt;/a>, &lt;a href="http://ekg2.org/" title="Ekg2 Multichat Client">Ekg2&lt;/a> or &lt;a href="http://tmux.sourceforge.net/" title="Tmux Terminal Multiplexer">Tmux&lt;/a> configurations. On the other hand some I keep publicly available for others i.e. on &lt;a href="https://github.com/taihen" title="GitHub Taihen">GitHub&lt;/a> like &lt;a href="https://github.com/taihen/vimfiles">Vim configs&lt;/a>. And oh boy, there are so many of them! The true is, I customize almost everything that I’m using including simple tools like cp (just to get progress bar or interactivity).&lt;/p></description></item><item><title>What ever happend to IPv5</title><link>https://taihen.org/posts/ipv5/</link><pubDate>Fri, 25 Jan 2013 22:36:36 +0100</pubDate><guid>https://taihen.org/posts/ipv5/</guid><description>&lt;p>Back in 1994, a new Internet Protocol was in the works—&lt;strong>Internet Protocol next generation (IPng)&lt;/strong>—which eventually became &lt;strong>IPv6&lt;/strong>. The goal was to have it up and running by 1996, with the idea that by the time IPv4 addresses ran out, everyone would already be using IPv6. Well… that didn’t quite go as planned. As of last year, global adoption of IPv6 only just hit &lt;strong>1%&lt;/strong>.&lt;/p>
&lt;p>Interestingly, in the early days, IPng was actually labeled as &lt;strong>version 7&lt;/strong>. But skipping version numbers—especially to an odd one—felt irrational, so it was quickly corrected to &lt;strong>version 6&lt;/strong> around the 26th IETF meeting. IPv6 was meant to be the savior of the internet, replacing the well-worn and rapidly depleting IPv4. It did this mainly by expanding address space from &lt;strong>32 bits to 128 bits&lt;/strong>, which seemed like an overwhelming amount at the time. IPv6 also introduced &lt;strong>anycast routing&lt;/strong>, removed checksums from the IP layer, and made several other improvements.&lt;/p></description></item><item><title>CLOCK: INSERTING LEAP SECOND 23:59:60 UTC</title><link>https://taihen.org/posts/leapsecond/</link><pubDate>Sun, 27 Sep 2009 22:36:36 +0100</pubDate><guid>https://taihen.org/posts/leapsecond/</guid><description>&lt;p>I found above message in a kernel log and I was just wondering what is all about. I was amazed how little I knew about it.&lt;/p>
&lt;blockquote>
&lt;p>A leap second is a second, as measured by an atomic clock, added to or subtracted from UTC to make it agree with astronomical time to within 0.9 second. It compensates for slowing in the Earth’s rotation and is added during the end of June or December. The first leap second was added to atomic clocks in 1972, with the most recent leap second being added on December 31, 2008.&lt;/p></description></item><item><title>January 1, 1970</title><link>https://taihen.org/posts/1970/</link><pubDate>Mon, 01 Oct 2007 22:36:36 +0100</pubDate><guid>https://taihen.org/posts/1970/</guid><description>&lt;p>The Unix epoch, defined as 00:00:00 UTC on January 1, 1970, serves as the foundational reference point for timekeeping in nearly all modern computing systems. This date, though seemingly arbitrary, emerged from a confluence of technical constraints, historical decisions, and practical considerations during Unix&amp;rsquo;s early development.&lt;/p>
&lt;h3 id="historical-context-of-unix-time">Historical Context of Unix Time&lt;/h3>
&lt;h4 id="early-development-of-unix-and-timekeeping">Early Development of Unix and Timekeeping&lt;/h4>
&lt;p>Unix, initially developed at Bell Labs in 1969, required a consistent method to track time for file management and process scheduling. Early versions of Unix stored time as a 32-bit integer counting 1/60-second intervals, a design influenced by the hardware clock frequency of the PDP-11 systems. This approach limited the maximum representable time span to approximately 829 days (~2.5 years), necessitating an epoch set in the recent past.&lt;/p></description></item></channel></rss>