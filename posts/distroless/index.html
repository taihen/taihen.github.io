<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Distroless Containers | taihen.org / 418 ... engineering in progress</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="If you’ve been in the container game for a while, you’ve probably seen a lot of buzz around “distroless” containers. The first time I heard the term, I pictured a container floating off into the void - no OS, no shell, just… code. Turns out, that’s not too far from the truth, but just like Serverless, Distroless is a misleading term!
Let’s break down what distroless containers are, why you might want them in your stack, what they’re great at (and not-so-great at), plus how to actually debug one."><meta name=generator content="Hugo 0.147.8"><meta name=robots content="index, follow"><link rel=stylesheet href=/ananke/css/main.min.8d048772ae72ab11245a0e296d1f2a36d3e3dd376c6c867394d6cc659c68fc37.css><link rel=canonical href=https://taihen.org/posts/distroless/><meta property="og:url" content="https://taihen.org/posts/distroless/"><meta property="og:site_name" content="taihen.org / 418 ... engineering in progress"><meta property="og:title" content="Distroless Containers"><meta property="og:description" content="If you’ve been in the container game for a while, you’ve probably seen a lot of buzz around “distroless” containers. The first time I heard the term, I pictured a container floating off into the void - no OS, no shell, just… code. Turns out, that’s not too far from the truth, but just like Serverless, Distroless is a misleading term!
Let’s break down what distroless containers are, why you might want them in your stack, what they’re great at (and not-so-great at), plus how to actually debug one."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-10T20:42:01+01:00"><meta property="article:modified_time" content="2025-06-10T20:42:01+01:00"><meta property="article:tag" content="Automation"><meta property="article:tag" content="Infrastructure"><meta property="article:tag" content="Cloud"><meta property="article:tag" content="IaC"><meta property="article:tag" content="DevOps"><meta property="article:tag" content="Containers"><meta itemprop=name content="Distroless Containers"><meta itemprop=description content="If you’ve been in the container game for a while, you’ve probably seen a lot of buzz around “distroless” containers. The first time I heard the term, I pictured a container floating off into the void - no OS, no shell, just… code. Turns out, that’s not too far from the truth, but just like Serverless, Distroless is a misleading term!
Let’s break down what distroless containers are, why you might want them in your stack, what they’re great at (and not-so-great at), plus how to actually debug one."><meta itemprop=datePublished content="2025-06-10T20:42:01+01:00"><meta itemprop=dateModified content="2025-06-10T20:42:01+01:00"><meta itemprop=wordCount content="1750"><meta itemprop=keywords content="Automation,Infrastructure,Cloud,IaC,DevOps,Containers,Docker,Kubernetes,Distroless"><meta name=twitter:card content="summary"><meta name=twitter:title content="Distroless Containers"><meta name=twitter:description content="If you’ve been in the container game for a while, you’ve probably seen a lot of buzz around “distroless” containers. The first time I heard the term, I pictured a container floating off into the void - no OS, no shell, just… code. Turns out, that’s not too far from the truth, but just like Serverless, Distroless is a misleading term!
Let’s break down what distroless containers are, why you might want them in your stack, what they’re great at (and not-so-great at), plus how to actually debug one."><script async src="https://www.googletagmanager.com/gtag/js?id=G-36HC46PNZV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-36HC46PNZV")}</script></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l center items-center justify-between"><a href=/ class="f3 fw2 hover-white white-90 dib no-underline">taihen.org / 418 ... engineering in progress</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/about/ title="About page">About</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/contact/ title="Contact page">Contact</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/posts/ title="Posts page">Posts</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white white-90 no-underline" href=/trainings/ title="Trainings page">Trainings</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l mw8 center ph3 flex-wrap justify-between"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Posts</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Distroless Containers</h1><time class="f6 mv4 dib tracked" datetime=2025-06-10T20:42:01+01:00>June 10, 2025</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>If you’ve been in the container game for a while, you’ve probably seen a lot of buzz around “distroless” containers. The first time I heard the term, <strong>I pictured a container floating off into the void - no OS, no shell, just… code</strong>. Turns out, that’s not too far from the truth, but just like Serverless, Distroless is a misleading term!</p><p>Let’s break down what distroless containers are, why you might want them in your stack, what they’re great at (and not-so-great at), plus how to actually debug one.</p><h2 id=so-whats-a-distroless-container>So, What’s a Distroless Container?</h2><p>Distroless containers are container images that contain only your application and its runtime dependencies - <strong>no shell, no package manager, no /bin/bash, nothing extra</strong>.</p><p>Imagine your regular container, but someone Marie Kondo’d every single binary out except the ones your app actually needs.</p><p>Instead of starting with Ubuntu, Debian, or Alpine, you start with&mldr; nothing. Or, more specifically, with a minimal image built to only run your app</p><h2 id=why-should-i-care>Why Should I Care?</h2><p>Pros:</p><ul><li>Security:
Smaller attack surface. If an attacker gets in, there’s no shell to exploit, no package manager to escalate with.</li><li>Tiny Images:
Fast pulls, less storage, less network.</li><li>Predictable Deployments:
“Works on my machine” issues go down deeper - if it’s not in the image, it’s not there, period.</li><li>Audit-Friendly:
You know exactly what’s in your container (and what isn’t).</li></ul><p>Cons:</p><ul><li>Debugging Is&mldr; Fun:
No shell or tools inside. Forget about <code>docker exec -it &lt;container> sh</code>.</li><li>You Need to Know Dependencies:
Miss one, and your app just won’t start.</li><li>Not for All Apps:
If your app needs to run scripts or expects OS tools, distroless isn’t a good fit (at least not out-of-the-box).</li></ul><h2 id=prime-examples-distroless-distributions>Prime Examples: Distroless Distributions</h2><ul><li>Google’s Distroless Images:
The OG and probably most popular. There are also runtime flavors for Java, Go, Node.js, Python, and more. Built to be drop-in for language-specific apps.</li><li>Chainguard Wolfi:
A “secure-by-default” Linux OS designed for containers, but still more minimal than Alpine or Debian, maintained.</li><li>Scratch:
The literal empty base image in Docker - just the bare minimum to boot an app (Heads up, with scratch, you bring your own everything).</li></ul><p>Each of these aims to cut out the cruft, shrink your images, and lower the risk surface.</p><h3 id=how-are-these-distroless-images-built>How Are These Distroless Images Built?</h3><h4 id=google-distroless-the-bazel-way>Google Distroless: The Bazel Way</h4><p>Google’s Distroless project is open source and uses Bazel for building. Bazel lets them define exactly what goes into each image, with strict dependency control.</p><p>What’s Actually in a Google Distroless Image?</p><ul><li>No shell</li><li>No package manager</li><li>Only the minimal system libraries or language runtime (e.g., OpenJDK for Java, libc for base, nothing for static)</li><li>Sometimes CA certificates for HTTPS</li></ul><p>How They Build:</p><ul><li>Use Bazel build system</li><li>Define everything in Bazel rules (BUILD and .bzl files)</li><li>Explicitly list what files and libraries get included (or not included)</li><li>Pull trusted Debian packages, then extract only required files (not whole packages)</li></ul><p>For example, peek at how the distroless/static-debian12 image is defined:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>load(<span style=color:#e6db74>&#34;@distroless//package_manager:dpkg.bzl&#34;</span>, <span style=color:#e6db74>&#34;dpkg_package&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dpkg_package(
</span></span><span style=display:flex><span>    name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ca-certificates&#34;</span>,
</span></span><span style=display:flex><span>    package <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ca-certificates&#34;</span>,
</span></span><span style=display:flex><span>    version <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;20240203&#34;</span>,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>container_image(
</span></span><span style=display:flex><span>    name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;static-debian12&#34;</span>,
</span></span><span style=display:flex><span>    base <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>,
</span></span><span style=display:flex><span>    files <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;:ca-certificates&#34;</span>,
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>    entrypoint <span style=color:#f92672>=</span> [],
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><ul><li>Bazel downloads the exact .deb files from Debian mirrors.</li><li>It extracts just the files needed (like certs) and puts them in the image.</li><li>There’s no /bin/sh, /usr/bin/apt, or any of that.</li><li>The root filesystem is then exported as a minimal OCI/Docker image.</li></ul><p>For more, check their <a href=https://github.com/GoogleContainerTools/distroless>official repo</a> and <a href=https://github.com/GoogleContainerTools/distroless/blob/main/BUILD.bazel>build rules</a>.</p><h4 id=chainguard-the-apkowolfi-way>Chainguard: The apko/Wolfi Way</h4><p>Chainguard has their own <a href=https://github.com/wolfi-dev/os>Wolfi Linux</a> as the build foundation, but for distroless/static images, they also strip out everything non-essential.</p><p>How They Build:</p><ul><li>Use <a href=https://github.com/chainguard-dev/apko>apko</a>, their declarative OCI image builder</li><li>Define image contents in YAML (apko.yaml)</li><li>Pull only specific, minimal Wolfi packages</li><li>Build in a way that produces a provenance (SBOM) and signature for supply chain security</li></ul><p>For example, chainguard/static image build <a href=https://github.com/chainguard-images/images/blob/main/images/static/apko.yaml>check their static image definition</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>contents</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>packages</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>ca-certificates-bundle</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>wolfi-baselayout</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>entrypoint</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>command</span>: []
</span></span><span style=display:flex><span><span style=color:#f92672>work-dir</span>: <span style=color:#ae81ff>/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>accounts</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>users</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nonroot</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>uid</span>: <span style=color:#ae81ff>65532</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>gid</span>: <span style=color:#ae81ff>65532</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>home</span>: <span style=color:#ae81ff>/home/nonroot</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>shell</span>: <span style=color:#ae81ff>/sbin/nologin</span>
</span></span></code></pre></div><ul><li>apko reads this YAML, grabs just those packages, and makes an image with nothing else.</li><li>No shell, no busybox, no package manager.</li><li>All images are signed and come with SBOMs for auditing.</li></ul><p>Their images are automatically rebuilt and updated when upstream packages change, keeping things super fresh and secure.</p><p>Read more and see the full <a href=https://github.com/chainguard-images/images/blob/main/images/static/apko.yaml>apko static definition here</a>.</p><h3 id=example-dockerfile>Example <code>Dockerfile</code></h3><p>This step is not that different than any other container build that you&rsquo;ve probably already seen - just a multistage <code>Dockerfile</code>.</p><p>Suppose you have this simple Go HTTP server:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Hello, world! From Go %s\n&#34;</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Getenv</span>(<span style=color:#e6db74>&#34;GOVERSION&#34;</span>))
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8080&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=with-google-distroless>With Google Distroless</h4><p>Google’s Distroless images are basically the gold standard. For Go, they recommend the <code>gcr.io/distroless/static</code> or, for apps that need glibc, <code>gcr.io/distroless/base</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#75715e># Build Stage</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> golang:1.24 as builder</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> CGO_ENABLED<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RUN</span> go build -o app .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Distroless Stage</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> gcr.io/distroless/static</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>builder /app/app /app<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> GOVERSION<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>.24<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>USER</span><span style=color:#e6db74> nonroot:nonroot</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;/app&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>How it works:</p><ul><li>Use Go 1.24 for building.</li><li>Set <code>CGO_ENABLED=0</code> to produce a static binary (no libc/glibc dependencies).</li><li>Use <code>gcr.io/distroless/static</code> as the runtime image. This image contains only minimal libraries (not even a shell).</li><li>Set an env variable for demo.</li><li>Runs as a non-privileged user.</li></ul><h4 id=with-chainguard-distroless>With Chainguard Distroless</h4><p>Chainguard Images are another great, secure, minimal alternative. They’re signed, SBOM-enabled, and often more up-to-date than Google’s due to rolling updates. (Wolfi is rolling Linux distribution, so similar philosophy to Arch or Gentoo)</p><p>Chainguard has images for Go (chainguard.dev Go base), as well as a general-purpose distroless image called chainguard/static.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=display:flex><span><span style=color:#75715e># Build Stage</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> cgr.dev/chainguard/go:1.24 as builder</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> CGO_ENABLED<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>RUN</span> go build -o app .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Distroless Stage</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> cgr.dev/chainguard/static</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>builder /app/app /app<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> GOVERSION<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>.24<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>USER</span><span style=color:#e6db74> 65532:65532</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;/app&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>How it works:</p><ul><li>Uses <code>cgr.dev/chainguard/go:1.24</code> for building.</li><li>Produces a static binary with Go 1.24.</li><li>Uses <code>cgr.dev/chainguard/static</code> as the distroless image.</li><li>Runs as a non-privileged user.</li></ul><h2 id=debugging-distroless-containers-the-real-world-way>Debugging Distroless Containers: The Real-World Way</h2><p>Okay, so you built your shiny, ultra-minimal distroless container. You deploy…
And something breaks. Uh-oh, what now?</p><p>Here’s the problem: there’s no shell, no way to <code>docker exec -it &lt;container> /bin/bash</code> in.</p><p>How do you debug then?</p><h3 id=ephemeral-debug-containers-kubernetes>Ephemeral Debug Containers (Kubernetes)</h3><p>If you’re on Kubernetes (at least 1.25) you can add ephemeral containers to a running Pod:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl debug -it &lt;your-pod&gt; --image<span style=color:#f92672>=</span>&lt;debug-container&gt; --target<span style=color:#f92672>=</span>&lt;your-container&gt;
</span></span></code></pre></div><p>This spins up a debug container, then in the same pod you have a shell and all required tools.</p><h3 id=temporary-debuggable-images>Temporary Debuggable Images</h3><p>If you’re troubleshooting locally, swap the base image for something with a shell (like Debian):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>FROM debian:bookworm-slim
</span></span><span style=display:flex><span>COPY --from<span style=color:#f92672>=</span>builder /app/app /app
</span></span><span style=display:flex><span>ENTRYPOINT <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;/app&#34;</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Now you can <code>docker exec -it &lt;container> /bin/bash</code>.</p><blockquote><p>It is common practice to build at least two types of base container images:</p><ul><li>latest:
A minimal production ready base image.</li><li>debug:
An image that contains also a shell and/or any other tooling which you might need for application development and debugging purposes,</li></ul><p>This approach simplifies development while providing the same building block (instead of using ie. completely different image with different underlying Linux distribution).</p></blockquote><h3 id=enhanced-logging>Enhanced Logging</h3><p>Because you can’t poke around inside, make your Go app extra chatty:</p><ul><li>Print config, env, and version on startup</li><li>Add /debug/pprof endpoints for introspection</li><li>Log important lifecycle events</li></ul><h3 id=chroot-debug-local-docker>Chroot Debug (local Docker)</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>docker run --rm -it --pid<span style=color:#f92672>=</span>container:&lt;your-container-id&gt; --network<span style=color:#f92672>=</span>container:&lt;your-container-id&gt; -v /:/host busybox chroot /host
</span></span></code></pre></div><p>This gives you a shell on your container’s filesystem—handy for the brave.</p><h2 id=why-all-this-matters>Why All This Matters</h2><p>Both Google and Chainguard go to extreme lengths to:</p><ul><li>Include only what’s truly needed</li><li>Build from trusted, minimal upstream sources (Debian/Wolfi)</li><li>Ensure everything is open, reproducible, and auditable</li><li>Make images signed and easy to verify (especially Chainguard)</li></ul><p><strong>The end result?</strong></p><p><strong>Production containers that are tiny, secure, and predictable.</strong></p><h2 id=i-build-my-own-images>I Build My Own Images!</h2><p>You don&rsquo;t have to use any the public Distroless base images, you can just build your own one! There are many legitimate reason to do so.</p><ol><li>Precise Control Over What’s Included</li></ol><ul><li>Only what you need, nothing more:
You decide exactly which files, libraries, and tools are present.</li><li>Custom dependencies:
Official distroless images are generic; maybe you need a specific shared library, locale, or custom CA bundle.</li></ul><ol start=2><li>Security & Compliance</li></ol><ul><li>Meet your dreadful organization’s security policies:
Need to audit every file? Require custom hardening or only trusted sources?</li><li>Provenance:
You know the origin of every package and file, which is crucial for regulated environments or when you must comply with frameworks like SLSA, CIS, or PCI-DSS.</li></ul><ol start=3><li>Supply Chain Transparency</li></ol><ul><li>You own your SBOM:
Generating your own Software Bill of Materials means you (not a third party) can guarantee what’s in your container.</li><li>Reproducible builds:
You can rebuild your images whenever dependencies are patched (think OpenSSL zero-day), and not wait for the upstream base to update.</li></ul><ol start=4><li>Customization & Optimization</li></ol><ul><li>Performance tuning:
You might want to optimize for startup speed or size by stripping even more than the public images.</li><li>Add your own users, entrypoints, or app conventions:
For instance, set a default non-root user that fits your internal UID/GID schema.</li><li>Multi-arch support:
Official images sometimes lag behind on ARM64, RISC-V, etc.</li></ul><ol start=5><li>Isolation for Special Use Cases</li></ol><ul><li>Non-standard languages/runtimes:
If you use a custom or less-common language/runtime, there may not be an official distroless for it.</li><li>Legacy app support:
Sometimes your dependencies need an older or patched system library version, not what’s in the upstream distroless.</li></ul><ol start=6><li>Faster Patching & Release Cadence</li></ol><ul><li>Control over updates:
Security fixes, new versions, and bug patches can be applied on your schedule, not someone else’s.</li></ul><ol start=7><li>Educational Value & Internal Trust</li></ol><ul><li>Better understanding:
Building your own distroless image is a great way to learn about Linux packaging, containers, and supply chain security.</li><li>Internal trust:
Teams may trust internally-built images more than third-party ones, especially for critical infrastructure.</li></ul><p>All the tools that both Google and Chainguard is using for their builds are Open Sourced and their projects are great examples of how to use them.</p><p>I&rsquo;ve build my own Distroless super minimal image using apko and Wolfi - it is great example how you can build your own one:</p><ul><li><a href=https://github.com/taihen/base-image>https://github.com/taihen/base-image</a></li></ul><h2 id=final-thoughts>Final Thoughts</h2><p>Distroless containers are like carrying only what you absolutely need on a trip - no extra baggage, way less to lose, and much harder for a thief to rob you.</p><p>For production, they’re a win for security and efficiency.</p><p>Just don’t forget: debugging is a little trickier, but with some clever workarounds (and good logs!), you can be fearless - even with distroless!</p><ul class=pa0><li class="list di"><a href=/tags/automation/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Automation</a></li><li class="list di"><a href=/tags/infrastructure/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Infrastructure</a></li><li class="list di"><a href=/tags/cloud/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Cloud</a></li><li class="list di"><a href=/tags/iac/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">IaC</a></li><li class="list di"><a href=/tags/devops/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">DevOps</a></li><li class="list di"><a href=/tags/containers/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Containers</a></li><li class="list di"><a href=/tags/docker/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Docker</a></li><li class="list di"><a href=/tags/kubernetes/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Kubernetes</a></li><li class="list di"><a href=/tags/distroless/ class="link f5 grow br-pill ba ph3 pv2 mb2 dib black sans-serif no-underline">Distroless</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/posts/configuration_management/>The Evolution of Configuration Management</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href=https://taihen.org/>&copy; taihen.org / 418 ... engineering in progress 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>